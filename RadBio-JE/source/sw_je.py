# -*- coding: utf-8 -*-
"""
/***************************************************************************
 software
                                 A QGIS plugin
 Software pro predikci obsahu radionuklidů v rostlinách

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-08
        git sha              : $Format:%H$
        copyright            : (C) 2021 by sai
        email                : s.a.isachenko@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtCore import *
from qgis.core import QgsProcessingFeedback
from PyQt5.QtCore import QVariant, QTimer
#from PyQt5.QtWidgets import QApplication
from qgis.PyQt.QtGui import QIcon, QPixmap
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QProgressBar, QApplication, QProgressDialog
from qgis.core import QgsProject, QgsField
import sys
import json
import math
import time

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .sw_je_dialog import softwareDialog
import os.path
import processing


if hasattr(QtCore.Qt, 'AA_EnableHighDpiScaling'):
    QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)

if hasattr(QtCore.Qt, 'AA_UseHighDpiPixmaps'):
    QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)


class software:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'software_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Predikce obsahu radionuklidů v rostlinách')
        self.errMessage = str()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('software', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/sw_je/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'RadBio-JE: Predikce obsahu radionuklidů v rostlinách v okolí JE'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Predikce obsahu radionuklidů v rostlinách'),
                action)
            self.iface.removeToolBarIcon(action)

    def showInfo(self):
        logo_mv = QPixmap(os.path.join(self.plugin_dir, "params/mv_cr.png"))
        msgBox = QMessageBox()
        msgBox.setIconPixmap(logo_mv.scaledToHeight(128, QtCore.Qt.SmoothTransformation))
        msgBox.setText("Vývoj tohoto programu byl podpořen z projektu Ministerstva vnitra ČR VI20192022153 - Optimalizace postupů pro realizaci rostlinné výroby na území zasaženém jadernou havárii.")
        msgBox.setWindowTitle("RadBio-JE")
        msgBox.setStandardButtons(QMessageBox.Ok)
        msgBox.button(QMessageBox.Ok).hide()
        QTimer.singleShot(5000, msgBox.close)
        msgBox.exec_()

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False

            if hasattr(QtCore.Qt, 'AA_EnableHighDpiScaling'): 
                QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True) 
            self.dlg = softwareDialog()
            self.dlg.refreshLayers.setIcon(QIcon(":/plugins/sw_je/refresh.png"))
            # Read dbf
            self.base = self.getJSONDBintegrateIntoDictR()
            # start procedures
            self.init_cb_layers()
            self.init_cb_funkce_tk()
            self.initComboSkupina()
            self.initComboPodskupina()
            self.initComboDruh()
            self.changedDruh()
            # connect procedures
            self.dlg.comboSkupina.currentTextChanged.connect(self.initComboPodskupina)
            self.dlg.comboPodskupina.currentTextChanged.connect(self.initComboDruh)
            self.dlg.comboDruh.currentTextChanged.connect(self.changedDruh)
            self.dlg.refreshLayers.clicked.connect(self.init_cb_layers)
            self.dlg.mainButton.clicked.connect(self.mainAction)
            self.dlg.TK_agregovany.stateChanged.connect(self.chb_agregovany_state)
            self.pb = QProgressBar(self.iface.statusBarIface())
            self.pb.setMaximumWidth(100)
            self.pb.setMaximumHeight(18)
            self.iface.statusBarIface().addPermanentWidget(self.pb, 1)
            self.pb.hide()
            self.showInfo()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

# procedures
    def mainAction(self):
        try:
            layer = QgsProject.instance().mapLayersByName(self.dlg.cb_layers.currentText())[0]
            self.iface.setActiveLayer(layer)

            if self.dlg.sb_rok_predikce.value() < self.dlg.sb_rok_havarie.value():
                self.dlg.sb_rok_predikce.setValue(self.dlg.sb_rok_havarie.value())

            result = self.calculate()

            self.init_cb_layers()
        except:
            response = QMessageBox(QMessageBox.Information, "Pozor", "Vyberte vektorovou vrstvu", QMessageBox.Ok)
            response.exec_()
    

    def chb_agregovany_state(self):
        if self.dlg.TK_agregovany.isChecked():
            self.dlg.cpuda_cs_a.setDisabled(True)
            self.dlg.cpuda_cs_b.setDisabled(True)
            self.dlg.cpuda_sr_a.setDisabled(True)
            self.dlg.cpuda_sr_b.setDisabled(True)
            self.dlg.cpuda_pu_a.setDisabled(True)
            self.dlg.cpuda_pu_b.setDisabled(True)
            self.dlg.costatni_cs_a.setDisabled(True)
            self.dlg.costatni_cs_b.setDisabled(True)
            self.dlg.costatni_sr_a.setDisabled(True)
            self.dlg.costatni_sr_b.setDisabled(True)
            self.dlg.costatni_pu_a.setDisabled(True)
            self.dlg.costatni_pu_b.setDisabled(True)
            self.dlg.sb_c_klima.setDisabled(True)
        else:
            self.dlg.cpuda_cs_a.setEnabled(True)
            self.dlg.cpuda_cs_b.setEnabled(True)
            self.dlg.cpuda_sr_a.setEnabled(True)
            self.dlg.cpuda_sr_b.setEnabled(True)
            self.dlg.cpuda_pu_a.setEnabled(True)
            self.dlg.cpuda_pu_b.setEnabled(True)
            self.dlg.costatni_cs_a.setEnabled(True)
            self.dlg.costatni_cs_b.setEnabled(True)
            self.dlg.costatni_sr_a.setEnabled(True)
            self.dlg.costatni_sr_b.setEnabled(True)
            self.dlg.costatni_pu_a.setEnabled(True)
            self.dlg.costatni_pu_b.setEnabled(True)
            self.dlg.sb_c_klima.setEnabled(True)


    def calculate(self):
        # init all variables
        rok_havarie: int = self.dlg.sb_rok_havarie.value()
        funkce_tk: int = self.dlg.cb_funkce_tk.currentData()
        c_klima: float = self.dlg.sb_c_klima.value()
        c_ostatni_cs_a: float = self.dlg.costatni_cs_a.value()
        c_ostatni_cs_b: float = self.dlg.costatni_cs_b.value()
        c_ostatni_sr_a: float = self.dlg.costatni_sr_a.value()
        c_ostatni_sr_b: float = self.dlg.costatni_sr_b.value()
        c_ostatni_pu_a: float = self.dlg.costatni_pu_a.value()
        c_ostatni_pu_b: float = self.dlg.costatni_pu_b.value()
        c_puda_cs_a: float = self.dlg.cpuda_cs_a.value()
        c_puda_cs_b: float = self.dlg.cpuda_cs_b.value()
        c_puda_sr_a: float = self.dlg.cpuda_sr_a.value()
        c_puda_sr_b: float = self.dlg.cpuda_sr_b.value()
        c_puda_pu_a: float = self.dlg.cpuda_pu_a.value()
        c_puda_pu_b: float = self.dlg.cpuda_pu_b.value()
        nasobichi_faktor: float = self.dlg.sb_nasobichi_faktor.value()
        rok_predikce: int = self.dlg.sb_rok_predikce.value()
        rok_predikce = rok_predikce if rok_predikce > rok_havarie else rok_havarie
        popis: str = str(self.dlg.popis.text())
        cast: str = str(self.dlg.cast.text())
        txt_rostlina: str = str(popis + ' (' + cast + ')')
        rostlina_id: int = self.dlg.comboDruh.currentData()
        meza_cs: int = self.dlg.sb_cs.value()
        meza_sr: int = self.dlg.sb_sr.value()
        meza_pu: int = self.dlg.sb_pu.value()
        txt_name: str = txt_rostlina + ', rok ' + str(rok_predikce) + ', Mezi: ' + str(meza_cs) + ' Cs, ' + str(meza_sr) + ' Sr, ' + str(meza_pu) + ' Pu'
        use_TKagr: bool = self.dlg.TK_agregovany.isChecked()
        use_interpolation: bool = self.dlg.activita_ve_spadu.isChecked()
        hlCS: float = 30.167
        hlSR: float = 28.797
        hlPU: float = 6561
        ln2: float = 0.693147181
        i_rok = rok_predikce - rok_havarie

        # read databases
        b_cs_agrch = self.read_CS_AGRCH()
        b_cs_time = self.read_CS_TIME()
        b_sr_agrch = self.read_SR_AGRCH()
        b_sr_time = self.read_SR_TIME()
        b_pu_agrch = self.read_PU_AGRCH()
        b_pu_time = self.read_PU_TIME()
        b_c_puda = self.read_C_PUDA()

        layer = self.iface.activeLayer()
        
        try:
            layer.selectAll()
            
            clone = processing.run("native:saveselectedfeatures", {'INPUT': layer, 'OUTPUT': 'memory:'})['OUTPUT']
            layer.removeSelection()
            
            featureCount = layer.featureCount()

            # progress bar
            progressMessageBar = self.iface.messageBar().createMessage("Probíhá výpočet ...")
            # progress = QProgressBar()
            # progress.setMaximum(featureCount)
            # progressMessageBar.layout().addWidget(progress)
            self.iface.messageBar().pushWidget(progressMessageBar, 0)
            self.pb.show()
            time.sleep(0.5)
            i = 0
            
            # create new field
            data_provider=clone.dataProvider()
            clone.startEditing()
            
            data_provider.addAttributes([QgsField('rostlina', QVariant.String)])
            data_provider.addAttributes([QgsField('rok_predikce', QVariant.Int)])
            data_provider.addAttributes([QgsField('aktivita_Cs_avg', QVariant.Double)])
            data_provider.addAttributes([QgsField('aktivita_Cs_min', QVariant.Double)])
            data_provider.addAttributes([QgsField('aktivita_Cs_max', QVariant.Double)])
            data_provider.addAttributes([QgsField('aktivita_Sr_avg', QVariant.Double)])
            data_provider.addAttributes([QgsField('aktivita_Sr_min', QVariant.Double)])
            data_provider.addAttributes([QgsField('aktivita_Sr_max', QVariant.Double)])
            data_provider.addAttributes([QgsField('aktivita_Pu_avg', QVariant.Double)])
            data_provider.addAttributes([QgsField('aktivita_Pu_min', QVariant.Double)])
            data_provider.addAttributes([QgsField('aktivita_Pu_max', QVariant.Double)])
            data_provider.addAttributes([QgsField('meza_Cs', QVariant.Int)])
            data_provider.addAttributes([QgsField('rok_Cs_min', QVariant.Int)])
            data_provider.addAttributes([QgsField('rok_Cs_max', QVariant.Int)])
            data_provider.addAttributes([QgsField('meza_Sr', QVariant.Int)])
            data_provider.addAttributes([QgsField('rok_Sr_min', QVariant.Int)])
            data_provider.addAttributes([QgsField('rok_Sr_max', QVariant.Int)])
            data_provider.addAttributes([QgsField('meza_Pu', QVariant.Int)])
            data_provider.addAttributes([QgsField('rok_Pu_min', QVariant.Int)])
            data_provider.addAttributes([QgsField('rok_Pu_max', QVariant.Int)])

            clone.updateFields()        
            
            # work with db
            features = clone.getFeatures()

            # init databases for TKtime
            cs_timedata = b_cs_time[rostlina_id]
            sr_timedata = b_sr_time[rostlina_id]
            pu_timedata = b_pu_time[rostlina_id]
            # init databases for TKagrch
            cs_agrodata = b_cs_agrch[rostlina_id]
            sr_agrodata = b_sr_agrch[rostlina_id]
            pu_agrodata = b_pu_agrch[rostlina_id]
            i = 0
            # work with line
            for feature in features:
                # read init from line
                i += 1
                main_Kultura = str(feature['Kultura'])
                if use_interpolation:
                    # interpolovaná hodnota pro rok havarii
                    main_CS_sp_prum = float(feature['Cs_sp_prum'])
                    main_CS_sp_min = float(feature['Cs_sp_min'])
                    main_CS_sp_max = float(feature['Cs_sp_max'])
                    main_SR_sp_prum = float(feature['Sr_sp_prum'])
                    main_SR_sp_min = float(feature['Sr_sp_min'])
                    main_SR_sp_max = float(feature['Sr_sp_max'])
                    main_PU_sp_prum = float(feature['Pu_sp_prum'])
                    main_PU_sp_min = float(feature['Pu_sp_min'])
                    main_PU_sp_max = float(feature['Pu_sp_max'])
                    # Cpremenna
                    Cpremenna_cs = math.exp(- ln2 * (rok_predikce - rok_havarie) / hlCS)
                    Cpremenna_sr = math.exp(- ln2 * (rok_predikce - rok_havarie) / hlSR)
                    Cpremenna_pu = math.exp(- ln2 * (rok_predikce - rok_havarie) / hlPU)
                    # výpočet rozdílu mezi rokem havárie a rokem stanovení aktivity
                    rok_odstup_cs = 0
                    rok_odstup_sr = 0
                    rok_odstup_pu = 0
                    # Costatni
                    if use_TKagr:
                        Costatni_cs = 1
                        Costatni_sr = 1
                        Costatni_pu = 1
                    else:
                        Costatni_cs = c_ostatni_cs_a * math.exp(c_ostatni_cs_b * (rok_predikce - rok_havarie))
                        Costatni_sr = c_ostatni_sr_a * math.exp(c_ostatni_sr_b * (rok_predikce - rok_havarie))
                        Costatni_pu = c_ostatni_pu_a * math.exp(c_ostatni_pu_b * (rok_predikce - rok_havarie))
                else:
                    # rok, kdy byla hodnota naměřena
                    cs_rok = int(feature['Cs_rok'])
                    sr_rok = int(feature['Sr_rok'])
                    pu_rok = int(feature['Pu_rok'])
                    # výpočet rozdílu mezi rokem havárie a rokem stanovení aktivity
                    rok_odstup_cs = cs_rok - rok_havarie
                    rok_odstup_sr = sr_rok - rok_havarie
                    rok_odstup_pu = sr_rok - rok_havarie

                    # kontroluje, zda předpovědní rok není nižší než rok měření radionuklidů 
                    rok_predikce_cs = rok_predikce if rok_predikce > cs_rok else cs_rok
                    rok_predikce_sr = rok_predikce if rok_predikce > sr_rok else sr_rok
                    rok_predikce_pu = rok_predikce if rok_predikce > pu_rok else pu_rok
                    # vypočítaná hodnota pro rok havarii
                    main_CS_sp_prum = float(feature['Cs_prum'])
                    main_CS_sp_min = float(feature['Cs_min'])
                    main_CS_sp_max = float(feature['Cs_max'])
                    main_SR_sp_prum = float(feature['Sr_prum'])
                    main_SR_sp_min = float(feature['Sr_min'])
                    main_SR_sp_max = float(feature['Sr_max'])
                    main_PU_sp_prum = float(feature['Pu_prum'])
                    main_PU_sp_min = float(feature['Pu_min'])
                    main_PU_sp_max = float(feature['Pu_max'])
                    # Cpremenna
                    Cpremenna_cs = math.exp(-ln2 * (rok_predikce_cs - cs_rok) / hlCS)
                    Cpremenna_sr = math.exp(-ln2 * (rok_predikce_sr - sr_rok) / hlSR)
                    Cpremenna_pu = math.exp(-ln2 * (rok_predikce_pu - pu_rok) / hlPU)
                    # Costatni
                    if use_TKagr:
                        Costatni_cs = 1
                        Costatni_sr = 1
                        Costatni_pu = 1
                    else:
                        Costatni_cs = c_ostatni_cs_a * math.exp(c_ostatni_cs_b * (rok_predikce - cs_rok))
                        Costatni_sr = c_ostatni_sr_a * math.exp(c_ostatni_sr_b * (rok_predikce - sr_rok))
                        Costatni_pu = c_ostatni_pu_a * math.exp(c_ostatni_pu_b * (rok_predikce - pu_rok))

                main_TYP_pudy = str(feature['Typ_pudy'])
                main_DRUH_pudy = str(feature['Druh_pudy'])
                main_PH_prum = float(feature['pH_prum'])
                main_PH_min = float(feature['pH_min'])
                main_PH_max = float(feature['pH_max'])
                main_COX_prum = float(feature['Cox_prum'])
                main_COX_min = float(feature['Cox_min'])
                main_COX_max = float(feature['Cox_max'])
                main_CA_prum = float(feature['Ca_prum'])
                main_CA_min = float(feature['Ca_min'])
                main_CA_max = float(feature['Ca_max'])
                main_K_prum = float(feature['K_prum'])
                main_K_min = float(feature['K_min'])
                main_K_max = float(feature['K_max'])
                main_MG_prum = float(feature['Mg_prum'])
                main_MG_min = float(feature['Mg_min'])
                main_MG_max = float(feature['Mg_max'])
                main_P_prum = float(feature['P_prum'])
                main_P_min = float(feature['P_min'])
                main_P_max = float(feature['P_max'])
                
                # Cpuda
                for ipuda in b_c_puda.values():
                    idx = ipuda.items()
                    if ('Kultura', main_Kultura) in idx:
                        if ('Druh_pudy', main_DRUH_pudy) in idx:
                            puda_PH_opt = float(ipuda['PH_opt'])
                            puda_PH_min = float(ipuda['PH_min'])
                            puda_COX_opt = float(ipuda['COX_opt'])
                            puda_COX_min = float(ipuda['COX_min'])
                            puda_CA_opt = float(ipuda['CA_opt'])
                            puda_CA_min = float(ipuda['CA_min'])
                            puda_K_opt = float(ipuda['K_opt'])
                            puda_K_min = float(ipuda['K_min'])
                            puda_MG_opt = float(ipuda['MG_opt'])
                            puda_MG_min = float(ipuda['MG_min'])
                            puda_P_opt = float(ipuda['P_opt'])
                            puda_P_min = float(ipuda['P_min'])

                                         

                I_ph_prum = self.corr_Index((main_PH_prum - puda_PH_min) / (puda_PH_opt - puda_PH_min))
                I_ph_min = self.corr_Index((main_PH_min - puda_PH_min) / (puda_PH_opt - puda_PH_min))
                I_ph_max = self.corr_Index((main_PH_max - puda_PH_min) / (puda_PH_opt - puda_PH_min))

                I_cox_prum = self.corr_Index((main_COX_prum - puda_COX_min) / (puda_COX_opt - puda_COX_min))
                I_cox_min = self.corr_Index((main_COX_min - puda_COX_min) / (puda_COX_opt - puda_COX_min))
                I_cox_max = self.corr_Index((main_COX_max - puda_COX_min) / (puda_COX_opt - puda_COX_min))
                
                I_ca_prum = self.corr_Index((main_CA_prum - puda_CA_min) / (puda_CA_opt - puda_CA_min))
                I_ca_min = self.corr_Index((main_CA_min - puda_CA_min) / (puda_CA_opt - puda_CA_min))
                I_ca_max = self.corr_Index((main_CA_max - puda_CA_min) / (puda_CA_opt - puda_CA_min))

                I_k_prum = self.corr_Index((main_K_prum - puda_K_min) / (puda_K_opt - puda_K_min))
                I_k_min = self.corr_Index((main_K_min - puda_K_min) / (puda_K_opt - puda_K_min))
                I_k_max = self.corr_Index((main_K_max - puda_K_min) / (puda_K_opt - puda_K_min))

                I_mg_prum = self.corr_Index((main_MG_prum - puda_MG_min) / (puda_MG_opt - puda_MG_min))
                I_mg_min = self.corr_Index((main_MG_min - puda_MG_min) / (puda_MG_opt - puda_MG_min))
                I_mg_max = self.corr_Index((main_MG_max - puda_MG_min) / (puda_MG_opt - puda_MG_min))

                I_p_prum = self.corr_Index((main_P_prum - puda_P_min) / (puda_P_opt - puda_P_min))
                I_p_min = self.corr_Index((main_P_min - puda_P_min) / (puda_P_opt - puda_P_min))
                I_p_max = self.corr_Index((main_P_max - puda_P_min) / (puda_P_opt - puda_P_min))

                I_zurodneni_prum = (I_ph_prum + I_cox_prum + I_ca_prum + I_k_prum + I_mg_prum + I_p_prum) / 6
                I_zurodneni_min = (I_ph_min + I_cox_min + I_ca_min + I_k_min + I_mg_min + I_p_min) / 6
                I_zurodneni_max = (I_ph_max + I_cox_max + I_ca_max + I_k_max + I_mg_max + I_p_max) / 6
                
                # Cpuda
                if use_TKagr:
                    Cpuda_cs_prum, Cpuda_cs_min, Cpuda_cs_max = 1, 1, 1
                    Cpuda_sr_prum, Cpuda_sr_min, Cpuda_sr_max = 1, 1, 1
                    Cpuda_pu_prum, Cpuda_pu_min, Cpuda_pu_max = 1, 1, 1
                else:
                    Cpuda_cs_prum = c_puda_cs_a * I_zurodneni_prum + c_puda_cs_b
                    Cpuda_cs_min = c_puda_cs_a * I_zurodneni_min + c_puda_cs_b
                    Cpuda_cs_max = c_puda_cs_a * I_zurodneni_max + c_puda_cs_b

                    Cpuda_sr_prum = c_puda_sr_a * I_zurodneni_prum + c_puda_sr_b
                    Cpuda_sr_min = c_puda_sr_a * I_zurodneni_min + c_puda_sr_b
                    Cpuda_sr_max = c_puda_sr_a * I_zurodneni_max + c_puda_sr_b

                    Cpuda_pu_prum = c_puda_pu_a * I_zurodneni_prum + c_puda_pu_b
                    Cpuda_pu_min = c_puda_pu_a * I_zurodneni_min + c_puda_pu_b
                    Cpuda_pu_max = c_puda_pu_a * I_zurodneni_max + c_puda_pu_b
                
                # TKagrch
                if use_TKagr:
                    TKagrch_CS_prum, TKagrch_CS_min, TKagrch_CS_max = 1, 1, 1
                    TKagrch_SR_prum, TKagrch_SR_min, TKagrch_SR_max = 1, 1, 1
                    TKagrch_PU_prum, TKagrch_PU_min, TKagrch_PU_max = 1, 1, 1
                else:
                    # CS
                    cs_agrch_a = float(cs_agrodata['AGRCH_' + main_DRUH_pudy + '_a1'])
                    cs_agrch_b = float(cs_agrodata['AGRCH_' + main_DRUH_pudy + '_b1'])
                    TKagrch_CS_prum = cs_agrch_a * math.exp(cs_agrch_b * main_K_prum)
                    TKagrch_CS_min = cs_agrch_a * math.exp(cs_agrch_b * main_K_min)
                    TKagrch_CS_max = cs_agrch_a * math.exp(cs_agrch_b * main_K_max)

                    # SR
                    sr_agrch_a = float(sr_agrodata['AGRCH_' + main_DRUH_pudy + '_a1'])
                    sr_agrch_b = float(sr_agrodata['AGRCH_' + main_DRUH_pudy + '_b1'])
                    TKagrch_SR_prum = sr_agrch_a * math.exp(sr_agrch_b * main_PH_prum)
                    TKagrch_SR_min = sr_agrch_a * math.exp(sr_agrch_b * main_PH_min)
                    TKagrch_SR_max = sr_agrch_a * math.exp(sr_agrch_b * main_PH_max)

                    # PU
                    pu_agrch_a = float(pu_agrodata['AGRCH_' + main_DRUH_pudy + '_a1'])
                    pu_agrch_b = float(pu_agrodata['AGRCH_' + main_DRUH_pudy + '_b1'])
                    TKagrch_PU_prum = pu_agrch_a * math.exp(pu_agrch_b * main_PH_prum)
                    TKagrch_PU_min = pu_agrch_a * math.exp(pu_agrch_b * main_PH_min)
                    TKagrch_PU_max = pu_agrch_a * math.exp(pu_agrch_b * main_PH_max)
                # TKagrch

                # TKtime
                # CS
                if funkce_tk == 1:
                    cs_time_a_long = float(cs_timedata[main_TYP_pudy + '_a3'])
                    cs_time_b_long = float(cs_timedata[main_TYP_pudy + '_b3'])
                    cs_time_rok = 0
                    if i_rok <= int(cs_timedata[main_TYP_pudy + '_rp1']):
                        cs_time_a = float(cs_timedata[main_TYP_pudy + '_a1'])
                        cs_time_b = float(cs_timedata[main_TYP_pudy + '_b1'])
                        cs_time_rok = 1
                    elif i_rok <= int(cs_timedata[main_TYP_pudy + '_rp2']):
                        cs_time_a = float(cs_timedata[main_TYP_pudy + '_a2'])
                        cs_time_b = float(cs_timedata[main_TYP_pudy + '_b2'])
                    elif i_rok <= int(cs_timedata[main_TYP_pudy + '_rp3']):
                        cs_time_a = float(cs_timedata[main_TYP_pudy + '_a3'])
                        cs_time_b = float(cs_timedata[main_TYP_pudy + '_b3'])
                    else:
                        cs_time_a = float(cs_timedata[main_TYP_pudy + '_a3'])
                        cs_time_b = float(cs_timedata[main_TYP_pudy + '_b3'])
                elif funkce_tk == 2:
                    cs_time_a_long = float(cs_timedata[main_DRUH_pudy + '_a3'])
                    cs_time_b_long = float(cs_timedata[main_DRUH_pudy + '_b3'])
                    cs_time_rok = 0
                    if i_rok <= int(cs_timedata[main_DRUH_pudy + '_rp1']):
                        cs_time_a = float(cs_timedata[main_DRUH_pudy + '_a1'])
                        cs_time_b = float(cs_timedata[main_DRUH_pudy + '_b1'])
                        cs_time_rok = 1
                    elif i_rok <= int(cs_timedata[main_DRUH_pudy + '_rp2']):
                        cs_time_a = float(cs_timedata[main_DRUH_pudy + '_a2'])
                        cs_time_b = float(cs_timedata[main_DRUH_pudy + '_b2'])
                    elif i_rok <= int(cs_timedata[main_DRUH_pudy + '_rp3']):
                        cs_time_a = float(cs_timedata[main_DRUH_pudy + '_a3'])
                        cs_time_b = float(cs_timedata[main_DRUH_pudy + '_b3'])
                    else:
                        cs_time_a = float(cs_timedata[main_DRUH_pudy + '_a3'])
                        cs_time_b = float(cs_timedata[main_DRUH_pudy + '_b3'])
                TKtime_CS = cs_time_a * math.exp(cs_time_b * i_rok)

                # SR
                if funkce_tk == 1:
                    sr_time_a_long = float(sr_timedata[main_TYP_pudy + '_a3'])
                    sr_time_b_long = float(sr_timedata[main_TYP_pudy + '_b3'])
                    sr_time_rok = 0
                    if i_rok <= int(sr_timedata[main_TYP_pudy + '_rp1']):
                        sr_time_a = float(sr_timedata[main_TYP_pudy + '_a1'])
                        sr_time_b = float(sr_timedata[main_TYP_pudy + '_b1'])
                        sr_time_rok = 1
                    elif i_rok <= int(sr_timedata[main_TYP_pudy + '_rp2']):
                        sr_time_a = float(sr_timedata[main_TYP_pudy + '_a2'])
                        sr_time_b = float(sr_timedata[main_TYP_pudy + '_b2'])
                    elif i_rok <= int(sr_timedata[main_TYP_pudy + '_rp3']):
                        sr_time_a = float(sr_timedata[main_TYP_pudy + '_a3'])
                        sr_time_b = float(sr_timedata[main_TYP_pudy + '_b3'])
                    else:
                        sr_time_a = float(sr_timedata[main_TYP_pudy + '_a3'])
                        sr_time_b = float(sr_timedata[main_TYP_pudy + '_b3'])
                elif funkce_tk == 2:
                    sr_time_a_long = float(sr_timedata[main_DRUH_pudy + '_a3'])
                    sr_time_b_long = float(sr_timedata[main_DRUH_pudy + '_b3'])
                    sr_time_rok = 0
                    if i_rok <= int(sr_timedata[main_DRUH_pudy + '_rp1']):
                        sr_time_a = float(sr_timedata[main_DRUH_pudy + '_a1'])
                        sr_time_b = float(sr_timedata[main_DRUH_pudy + '_b1'])
                        sr_time_rok = 1
                    elif i_rok <= int(sr_timedata[main_DRUH_pudy + '_rp2']):
                        sr_time_a = float(sr_timedata[main_DRUH_pudy + '_a2'])
                        sr_time_b = float(sr_timedata[main_DRUH_pudy + '_b2'])
                    elif i_rok <= int(sr_timedata[main_DRUH_pudy + '_rp3']):
                        sr_time_a = float(sr_timedata[main_DRUH_pudy + '_a3'])
                        sr_time_b = float(sr_timedata[main_DRUH_pudy + '_b3'])
                    else:
                        sr_time_a = float(sr_timedata[main_DRUH_pudy + '_a3'])
                        sr_time_b = float(sr_timedata[main_DRUH_pudy + '_b3'])
                TKtime_SR = sr_time_a * math.exp(sr_time_b * i_rok)

                # PU
                if funkce_tk == 1:
                    pu_time_a_long = float(pu_timedata[main_TYP_pudy + '_a3'])
                    pu_time_b_long = float(pu_timedata[main_TYP_pudy + '_b3'])
                    pu_time_rok = 0
                    if i_rok <= int(pu_timedata[main_TYP_pudy + '_rp1']):
                        pu_time_a = float(pu_timedata[main_TYP_pudy + '_a1'])
                        pu_time_b = float(pu_timedata[main_TYP_pudy + '_b1'])
                        pu_time_rok = 1
                    elif i_rok <= int(pu_timedata[main_TYP_pudy + '_rp2']):
                        pu_time_a = float(pu_timedata[main_TYP_pudy + '_a2'])
                        pu_time_b = float(pu_timedata[main_TYP_pudy + '_b2'])
                    elif i_rok <= int(pu_timedata[main_TYP_pudy + '_rp3']):
                        pu_time_a = float(pu_timedata[main_TYP_pudy + '_a3'])
                        pu_time_b = float(pu_timedata[main_TYP_pudy + '_b3'])
                    else:
                        pu_time_a = float(pu_timedata[main_TYP_pudy + '_a3'])
                        pu_time_b = float(pu_timedata[main_TYP_pudy + '_b3'])
                elif funkce_tk == 2:
                    pu_time_a_long = float(pu_timedata[main_DRUH_pudy + '_a3'])
                    pu_time_b_long = float(pu_timedata[main_DRUH_pudy + '_b3'])
                    pu_time_rok = 0
                    if i_rok <= int(pu_timedata[main_DRUH_pudy + '_rp1']):
                        pu_time_a = float(pu_timedata[main_DRUH_pudy + '_a1'])
                        pu_time_b = float(pu_timedata[main_DRUH_pudy + '_b1'])
                        pu_time_rok = 1
                    elif i_rok <= int(pu_timedata[main_DRUH_pudy + '_rp2']):
                        pu_time_a = float(pu_timedata[main_DRUH_pudy + '_a2'])
                        pu_time_b = float(pu_timedata[main_DRUH_pudy + '_b2'])
                    elif i_rok <= int(pu_timedata[main_DRUH_pudy + '_rp3']):
                        pu_time_a = float(pu_timedata[main_DRUH_pudy + '_a3'])
                        pu_time_b = float(pu_timedata[main_DRUH_pudy + '_b3'])
                    else:
                        pu_time_a = float(pu_timedata[main_DRUH_pudy + '_a3'])
                        pu_time_b = float(pu_timedata[main_DRUH_pudy + '_b3'])
                TKtime_PU = pu_time_a * math.exp(pu_time_b * i_rok)
                # TKtime

                # Cklima
                Cklima = c_klima

                # Kalculace aktivity
                aktivita_Cs_avg = main_CS_sp_prum * TKtime_CS * TKagrch_CS_prum * Cpremenna_cs * Cpuda_cs_prum * Cklima * Costatni_cs * nasobichi_faktor
                aktivita_Cs_min = main_CS_sp_min * TKtime_CS * TKagrch_CS_max * Cpremenna_cs * Cpuda_cs_max * Cklima * Costatni_cs * nasobichi_faktor
                aktivita_Cs_max = main_CS_sp_max * TKtime_CS * TKagrch_CS_min * Cpremenna_cs * Cpuda_cs_min * Cklima * Costatni_cs * nasobichi_faktor
                aktivita_Sr_avg = main_SR_sp_prum * TKtime_SR * TKagrch_SR_prum * Cpremenna_sr * Cpuda_sr_prum * Cklima * Costatni_sr * nasobichi_faktor
                aktivita_Sr_min = main_SR_sp_min * TKtime_SR * TKagrch_SR_max * Cpremenna_sr * Cpuda_sr_max * Cklima * Costatni_sr * nasobichi_faktor
                aktivita_Sr_max = main_SR_sp_max * TKtime_SR * TKagrch_SR_min * Cpremenna_sr * Cpuda_sr_min * Cklima * Costatni_sr * nasobichi_faktor
                aktivita_Pu_avg = main_PU_sp_prum * TKtime_PU * TKagrch_PU_prum * Cpremenna_pu * Cpuda_pu_prum * Cklima * Costatni_pu * nasobichi_faktor
                aktivita_Pu_min = main_PU_sp_min * TKtime_PU * TKagrch_PU_max * Cpremenna_pu * Cpuda_pu_max * Cklima * Costatni_pu * nasobichi_faktor
                aktivita_Pu_max = main_PU_sp_max * TKtime_PU * TKagrch_PU_min * Cpremenna_pu * Cpuda_pu_min * Cklima * Costatni_pu * nasobichi_faktor

                # Kalkulace mezneho roku
                ''' # Kalkulace pro rozpad radionuklidů 
                rok_Cs_min = math.log(meza_cs / (TKagrch_CS_max * main_CS_sp_min * Cpuda_cs_max * Cklima * Costatni_cs * nasobichi_faktor)) * hlCS / - ln2
                rok_Cs_max = math.log(meza_cs / (TKagrch_CS_min * main_CS_sp_max * Cpuda_cs_min * Cklima * Costatni_cs * nasobichi_faktor)) * hlCS / - ln2
                rok_Sr_min = math.log(meza_sr / (TKagrch_SR_max * main_SR_sp_min * Cpuda_sr_max * Cklima * Costatni_sr * nasobichi_faktor)) * hlSR / - ln2
                rok_Sr_max = math.log(meza_sr / (TKagrch_SR_min * main_SR_sp_max * Cpuda_sr_min * Cklima * Costatni_sr * nasobichi_faktor)) * hlSR / - ln2
                rok_Pu_min = math.log(meza_pu / (TKagrch_PU_max * main_PU_sp_min * Cpuda_pu_max * Cklima * Costatni_pu * nasobichi_faktor)) * hlPU / - ln2
                rok_Pu_max = math.log(meza_pu / (TKagrch_PU_min * main_PU_sp_max * Cpuda_pu_min * Cklima * Costatni_pu * nasobichi_faktor)) * hlPU / - ln2
                '''

                # Kalkulace pro změny TK od času 
                #CS
                if main_CS_sp_min > 0:
                    rok_Cs_min = max(
                        (math.log(meza_cs / (TKagrch_CS_max * main_CS_sp_min * Cpuda_cs_max * Cklima * nasobichi_faktor * cs_time_a*c_ostatni_cs_a)) + c_ostatni_cs_b*rok_odstup_cs - rok_odstup_cs*ln2 / hlCS ) * (1 / (c_ostatni_cs_b + cs_time_b - ln2 / hlCS)),
                        (math.log(meza_cs / (TKagrch_CS_max * main_CS_sp_min * Cpuda_cs_max * Cklima * nasobichi_faktor * cs_time_a_long*c_ostatni_cs_a)) + c_ostatni_cs_b*rok_odstup_cs - rok_odstup_cs*ln2 / hlCS ) * (1 / (c_ostatni_cs_b + cs_time_b_long - ln2 / hlCS))
                        )
                else:
                    rok_Cs_min = 0
                if main_CS_sp_max > 0:
                    rok_Cs_max = max(
                        (math.log(meza_cs / (TKagrch_CS_min * main_CS_sp_max * Cpuda_cs_min * Cklima * nasobichi_faktor * cs_time_a*c_ostatni_cs_a)) + c_ostatni_cs_b*rok_odstup_cs - rok_odstup_cs*ln2 / hlCS ) * (1 / (c_ostatni_cs_b + cs_time_b - ln2 / hlCS)),
                        (math.log(meza_cs / (TKagrch_CS_min * main_CS_sp_max * Cpuda_cs_min * Cklima * nasobichi_faktor * cs_time_a_long*c_ostatni_cs_a)) + c_ostatni_cs_b*rok_odstup_cs - rok_odstup_cs*ln2 / hlCS ) * (1 / (c_ostatni_cs_b + cs_time_b_long - ln2 / hlCS))
                        )
                else:
                    rok_Cs_max = 0
                #SR
                if main_SR_sp_min > 0:    
                    rok_Sr_min = max(
                        (math.log(meza_sr / (TKagrch_SR_max * main_SR_sp_min * Cpuda_sr_max * Cklima * nasobichi_faktor * sr_time_a*c_ostatni_sr_a)) + c_ostatni_sr_b*rok_odstup_sr - rok_odstup_sr*ln2 / hlSR ) * (1 / (c_ostatni_sr_b + sr_time_b - ln2 / hlSR)),
                        (math.log(meza_sr / (TKagrch_SR_max * main_SR_sp_min * Cpuda_sr_max * Cklima * nasobichi_faktor * sr_time_a_long*c_ostatni_sr_a)) + c_ostatni_sr_b*rok_odstup_sr - rok_odstup_sr*ln2 / hlSR ) * (1 / (c_ostatni_sr_b + sr_time_b_long - ln2 / hlSR))
                        )
                else:
                    rok_Sr_min = 0
                if main_SR_sp_max > 0:
                    rok_Sr_max = max(
                        (math.log(meza_sr / (TKagrch_SR_min * main_SR_sp_max * Cpuda_sr_min * Cklima * nasobichi_faktor * sr_time_a*c_ostatni_sr_a)) + c_ostatni_sr_b*rok_odstup_sr - rok_odstup_sr*ln2 / hlSR ) * (1 / (c_ostatni_sr_b + sr_time_b - ln2 / hlSR)),
                        (math.log(meza_sr / (TKagrch_SR_min * main_SR_sp_max * Cpuda_sr_min * Cklima * nasobichi_faktor * sr_time_a_long*c_ostatni_sr_a)) + c_ostatni_sr_b*rok_odstup_sr - rok_odstup_sr*ln2 / hlSR ) * (1 / (c_ostatni_sr_b + sr_time_b_long - ln2 / hlSR))
                        )
                else:
                    rok_Sr_max = 0
                #PU
                if main_PU_sp_min > 0:
                    rok_Pu_min = max(
                        (math.log(meza_pu / (TKagrch_PU_max * main_PU_sp_min * Cpuda_pu_max * Cklima * nasobichi_faktor * pu_time_a*c_ostatni_pu_a)) + c_ostatni_pu_b*rok_odstup_pu - rok_odstup_pu*ln2 / hlPU ) * (1 / (c_ostatni_pu_b + pu_time_b - ln2 / hlPU)),
                        (math.log(meza_pu / (TKagrch_PU_max * main_PU_sp_min * Cpuda_pu_max * Cklima * nasobichi_faktor * pu_time_a_long*c_ostatni_pu_a)) + c_ostatni_pu_b*rok_odstup_pu - rok_odstup_pu*ln2 / hlPU ) * (1 / (c_ostatni_pu_b + pu_time_b_long - ln2 / hlPU))
                        )
                else:
                    rok_Pu_min = 0
                if main_PU_sp_max > 0:
                    rok_Pu_max = max(
                        (math.log(meza_pu / (TKagrch_PU_min * main_PU_sp_max * Cpuda_pu_min * Cklima * nasobichi_faktor * pu_time_a*c_ostatni_pu_a)) + c_ostatni_pu_b*rok_odstup_pu - rok_odstup_pu*ln2 / hlPU ) * (1 / (c_ostatni_pu_b + pu_time_b - ln2 / hlPU)),
                        (math.log(meza_pu / (TKagrch_PU_min * main_PU_sp_max * Cpuda_pu_min * Cklima * nasobichi_faktor * pu_time_a_long*c_ostatni_pu_a)) + c_ostatni_pu_b*rok_odstup_pu - rok_odstup_pu*ln2 / hlPU ) * (1 / (c_ostatni_pu_b + pu_time_b_long - ln2 / hlPU))
                        )
                else:
                    rok_Pu_max = 0

                check = lambda check: check if check > 0 else 0
                
                rok_Cs_min = check(rok_Cs_min)
                rok_Cs_max = check(rok_Cs_max)
                rok_Sr_min = check(rok_Sr_min)
                rok_Sr_max = check(rok_Sr_max)
                rok_Pu_min = check(rok_Pu_min)
                rok_Pu_max = check(rok_Pu_max)

                feature['rostlina'] = txt_rostlina
                feature['rok_predikce'] = rok_predikce
                feature['aktivita_Cs_avg'] = round(aktivita_Cs_avg, 2)
                feature['aktivita_Cs_min'] = round(aktivita_Cs_min, 2)
                feature['aktivita_Cs_max'] = round(aktivita_Cs_max, 2)
                feature['aktivita_Sr_avg'] = round(aktivita_Sr_avg, 2)
                feature['aktivita_Sr_min'] = round(aktivita_Sr_min, 2)
                feature['aktivita_Sr_max'] = round(aktivita_Sr_max, 2)
                feature['aktivita_Pu_avg'] = round(aktivita_Pu_avg, 2)
                feature['aktivita_Pu_min'] = round(aktivita_Pu_min, 2)
                feature['aktivita_Pu_max'] = round(aktivita_Pu_max, 2)
                feature['meza_Cs'] = meza_cs
                feature['rok_Cs_min'] = math.ceil(rok_Cs_min + rok_havarie) 
                feature['rok_Cs_max'] = math.ceil(rok_Cs_max + rok_havarie)
                feature['meza_Sr'] = meza_sr
                feature['rok_Sr_min'] = math.ceil(rok_Sr_min + rok_havarie)
                feature['rok_Sr_max'] = math.ceil(rok_Sr_max + rok_havarie)
                feature['meza_Pu'] = meza_pu
                feature['rok_Pu_min'] = math.ceil(rok_Pu_min + rok_havarie)
                feature['rok_Pu_max'] = math.ceil(rok_Pu_max + rok_havarie)

                clone.updateFeature(feature)
                # progress bar
                i += 1
                percent = i / featureCount * 100
                self.iface.statusBarIface().showMessage("Probíhá výpočet. Zpracováno {} %".format(int(percent)))
                self.pb.setValue(percent)
                #progress.setValue(i)
                time.sleep(0.002)
                # progress bar

            clone.commitChanges()

            clone.setName(str(txt_name))

            QgsProject.instance().addMapLayer(clone)

            del clone
            
        except:
            response = QMessageBox(QMessageBox.Information, "Pozor", "Problém s vektorovou vrstvou nebo problém s daty. "+self.errMessage, QMessageBox.Ok)
            response.exec_()
        
        # progress bar
        self.iface.statusBarIface().clearMessage()
        self.iface.messageBar().clearWidgets()
        self.iface.messageBar().pushInfo(u"Výsledek", u"Dokončeno")
        self.pb.hide()
        # progress bar

        self.iface.mapCanvas().refresh()


    def progdialog(self, progress):
        dialog = QProgressDialog()
        dialog.setWindowTitle("Progress")
        dialog.setLabelText("text")
        bar = QProgressBar(dialog)
        bar.setTextVisible(True)
        bar.setValue(progress)
        dialog.setBar(bar)
        dialog.setMinimumWidth(300)
        dialog.show()
        return dialog, bar


    def corr_Index(self, index: float):
        if index < 0 :
            return 0
        if index > 1 :
            return 1
        return index


    def getJSONDBintegrateIntoDictR(self):
        with open(os.path.join(self.plugin_dir, "params/rostliny.json"), 'r', encoding='utf-8', errors='ignore') as file_object:
            contents = file_object.read()

        data: dict = json.loads(contents)

        if 'rostliny' in data:
            rostliny: dict = data['rostliny']
            base = {}
            i = 0
            for rostlina in rostliny:
                i = i + 1
                rstln = {}
                for key, value in rostlina.items():
                    rstln[key] = value
                base[i] = rstln
        return base


    def read_CS_AGRCH(self):
        with open(os.path.join(self.plugin_dir, "params/cs-agrch.json"), 'r', encoding='utf-8', errors='ignore') as file_object:
            contents = file_object.read()

        data: dict = json.loads(contents)

        if 'cs_agrch' in data:
            lines: dict = data['cs_agrch']
            base = {}
            i = 0
            for line in lines:
                i = i + 1
                lin = {}
                for key, value in line.items():
                    lin[key] = value
                base[i] = lin
        return base


    def read_CS_TIME(self):
        with open(os.path.join(self.plugin_dir, "params/cs-time.json"), 'r', encoding='utf-8', errors='ignore') as file_object:
            contents = file_object.read()

        data: dict = json.loads(contents)

        if 'cs_time' in data:
            lines: dict = data['cs_time']
            base = {}
            i = 0
            for line in lines:
                i = i + 1
                lin = {}
                for key, value in line.items():
                    lin[key] = value
                base[i] = lin
        return base


    def read_SR_AGRCH(self):
        with open(os.path.join(self.plugin_dir, "params/sr-agrch.json"), 'r', encoding='utf-8', errors='ignore') as file_object:
            contents = file_object.read()

        data: dict = json.loads(contents)

        if 'sr_agrch' in data:
            lines: dict = data['sr_agrch']
            base = {}
            i = 0
            for line in lines:
                i = i + 1
                lin = {}
                for key, value in line.items():
                    lin[key] = value
                base[i] = lin
        return base


    def read_SR_TIME(self):
        with open(os.path.join(self.plugin_dir, "params/sr-time.json"), 'r', encoding='utf-8', errors='ignore') as file_object:
            contents = file_object.read()

        data: dict = json.loads(contents)

        if 'sr_time' in data:
            lines: dict = data['sr_time']
            base = {}
            i = 0
            for line in lines:
                i = i + 1
                lin = {}
                for key, value in line.items():
                    lin[key] = value
                base[i] = lin
        return base


    def read_PU_AGRCH(self):
        with open(os.path.join(self.plugin_dir, "params/pu-agrch.json"), 'r', encoding='utf-8', errors='ignore') as file_object:
            contents = file_object.read()

        data: dict = json.loads(contents)

        if 'pu_agrch' in data:
            lines: dict = data['pu_agrch']
            base = {}
            i = 0
            for line in lines:
                i = i + 1
                lin = {}
                for key, value in line.items():
                    lin[key] = value
                base[i] = lin
        return base


    def read_PU_TIME(self):
        with open(os.path.join(self.plugin_dir, "params/pu-time.json"), 'r', encoding='utf-8', errors='ignore') as file_object:
            contents = file_object.read()

        data: dict = json.loads(contents)

        if 'pu_time' in data:
            lines: dict = data['pu_time']
            base = {}
            i = 0
            for line in lines:
                i = i + 1
                lin = {}
                for key, value in line.items():
                    lin[key] = value
                base[i] = lin
        return base


    def read_C_PUDA(self):
        with open(os.path.join(self.plugin_dir, "params/c-puda.json"), 'r', encoding='utf-8', errors='ignore') as file_object:
            contents = file_object.read()

        data: dict = json.loads(contents)

        if 'c_puda' in data:
            lines: dict = data['c_puda']
            base = {}
            i = 0
            for line in lines:
                i = i + 1
                lin = {}
                for key, value in line.items():
                    lin[key] = value
                base[i] = lin
        return base


    def generate(list1: list):
        r = []
        list1.sort()
        for element in list1:
            r.append({'label': element, 'value': element})
        return r


    def getSkupina(self, dictionary: dict):
        foundValues = set()
        for dic1 in dictionary.values():
            foundValues.add(dic1["Skupina"])
        return list(foundValues)


    def getPodskupina(self, dictionary: dict, skupina: str):
        foundValues = set()
        for dic1 in dictionary.values():
            dic2 = dic1.items()
            if ("Skupina", skupina) in dic2:
                foundValues.add(dic1["Podskupina"])
        return list(foundValues)


    def init_cb_funkce_tk(self):
        self.dlg.cb_funkce_tk.clear()
        self.dlg.cb_funkce_tk.addItem('Typ pudy')
        self.dlg.cb_funkce_tk.setItemData(0, 1)
        self.dlg.cb_funkce_tk.addItem('Druh pudy')
        self.dlg.cb_funkce_tk.setItemData(1, 2)

    def init_cb_layers(self):
        self.dlg.cb_layers.clear()
        lrs = set()
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            lrs.add(layer.name())
        self.dlg.cb_layers.insertItems(0, lrs)


    def initComboSkupina(self):
        self.dlg.comboSkupina.clear()
        skpn = self.getSkupina(self.base)
        self.dlg.comboSkupina.insertItems(0, skpn)
#        skpn.sort()
#        for i in skpn:
#            self.dlg.comboSkupina.addItem(i)


    def getDruh(self, dictionary: dict, skupina: str, podskupina: str):
        foundValues = set()
        for dic1 in dictionary.values():
            dic2 = dic1.items()
            if ("Skupina", skupina) in dic2:
                if ("Podskupina", podskupina) in dic2:
                    foundValues.add((dic1["Druh_rostliny"], dic1["Id"]))
        return list(foundValues)


    def initComboPodskupina(self):
        pskpn = self.getPodskupina(self.base, self.dlg.comboSkupina.currentText())
        pskpn.sort()
        self.dlg.comboPodskupina.clear()
        self.dlg.comboPodskupina.insertItems(0, pskpn)


    def initComboDruh(self):
        drh = self.getDruh(self.base, self.dlg.comboSkupina.currentText(), self.dlg.comboPodskupina.currentText())
        drh.sort()
        self.dlg.comboDruh.clear()
#        self.dlg.comboDruh.insertItems(0, drh)
        k = 0
        for drh, id in drh:
            self.dlg.comboDruh.addItem(drh)
            self.dlg.comboDruh.setItemData(k, int(id))
            k +=1


    def changedDruh(self):
        id = self.dlg.comboDruh.currentData()
        find = self.getInfo(self.base, str(id))
        self.dlg.popis.setText(find[0])
        self.dlg.cast.setText(find[1])


    def getInfo(self, dictionary: dict, wanted: str):
        for dic1 in dictionary.values():
            dic2 = dic1.items()
            if ("Id", wanted) in dic2:
                info = (dic1["Popis"], dic1["Cast_rostliny"])
                return info
        return ("na","na")
